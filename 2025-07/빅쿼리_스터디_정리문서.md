# BigQuery 살펴보기

## 웨어하우스 디자인

- 웨어하우스는 **데이터를 어떻게 저장하는가**에 대한 구조를 이해해야 한다.

---

## 데이터 저장소로서의 BigQuery

- 데이터는 최종적으로 **1차원 형태로 저장**됨
- 데이터베이스의 성능은 저장 방식과 밀접한 관련
- 저장 매체(RAM, 하드디스크 등)의 접근 속도 및 특징이 중요

출처: [Heavy.AI Columnar Database](https://www.heavy.ai/technical-glossary/columnar-database)

---

## 1. 행 지향 접근 (Row-Oriented)

### 예시

```
apple red round orange orange round banana yellow curved
```

- 전통적인 관계형 모델은 행 지향 방식을 사용
- **새로운 데이터 추가 시** → 테이블 끝에 삽입
- **조회 시** → 전체 테이블 로드 후 각 행을 탐색 → 성능 비용 큼
- **새 열 추가 시** → 모든 행에 새 값을 삽입해야 함
- 성능 향상을 위해 인덱스 사용
- **검색/수정**이 빈번한 경우 적합

---

## 2. 열 지향 접근 (Column-Oriented)

### 예시

```
name:  apple  orange  banana
color: red    orange  yellow
shape: round  round   curved
```

- 열 기반 저장소이므로 필요한 열만 접근
- 열의 데이터 유형을 알고 있어 **압축에 유리**
- 중복 값 압축 → 저장 효율 증가
- **단점**: 레코드 삽입 시 모든 열을 업데이트하고 동기화 유지 필요

---

## 데이터 웨어하우스로서의 BigQuery

- OLTP(DB처럼)로 사용하는 것은 비추천 (안티패턴)
  - `INSERT`, `UPDATE` 느림
  - 대신 **로드/스트리밍** 방식 추천
  - 인덱스 없음 → 키 기반 검색 비효율

---

## 주요 질문

### 1. 기초

- **해결할 문제**: 비즈니스 인사이트 제공
- **데이터 범위**: 웨어하우스에 포함 가능한 데이터
- **사용자**: 비즈니스 관계자, 데이터 분석가
- **이전 여부**: 기존 시스템에서의 마이그레이션 고려

### 2. 확장성

- **데이터 규모**: TB ~ PB 수준까지 계획 필요
- **증가 속도** 및 저장 비용 고려
- **사용자 수** 및 권한 설정
- **예산** 확인
- **실시간 처리 여부**

---

## 데이터 정규화 vs 비정규화

출처: [Capella Solutions](https://www.capellasolutions.com/blog/the-denormalize-database-manifesto-a-guide-to-challenging-traditional-structures)

- **정규화**:
  - 속성을 단일 위치에 저장
  - 중복 줄이고 키로 결합
- **비정규화**:
  - 모든 데이터를 하나의 테이블에 저장
  - 조인 피하지만 저장 공간 증가 및 무결성 이슈 발생 가능

---

## 요약

- BigQuery는 **Google이 제공하는 관리형 분석 엔진**
- 웹 UI, CLI, SDK 등 다양한 접근 방식 제공
- **트랜잭션 DB가 아니므로 자주 수정/삭제에는 적합하지 않음**
- 열 지향 저장소로서 **전통적 웨어하우스보다 효율성 있음**


# 빅쿼리를 활용한 데이터 웨어하우스 구축

## 웨어하우스 프로젝트 시작

### 시작에 앞서

- 새로운 데이터 웨어하우스를 구축하는 것은 어려운 작업이다.
  - 데이터 구조를 합리화하고 정규화하는 능력
  - 데이터 웨어하우스를 ‘적절한 크기'로 예측하는 방법
  - 비즈니스에 대한 이해

---

### 핵심 질문

- 제한적인 리소스는 무엇인가?
  - 돈, 인력, 시간의 세 축
    - 예산은 충분하지만 인력이 부족한가?
    - 이 작업을 수행할 팀이 다른 업무 중인가?

- 조직의 업무 분야는 무엇인가?
  - 예시: 물류 문제, 약국 체인

- 조직의 차별점은 무엇인가?
  - 어떤 독특한 스타일로 업무를 수행하는가?
    - 예: 위탁 판매점
      - 판매자는 품목을 가져와 판매
      - 직원은 품목을 기록하고 재고에 추가
      - 고객이 품목을 구매
      - ➝ 직원이 위탁 판매자 정보를 추가로 저장해야 함

- 필요한 데이터를 알려줄 수 있는 사람은 누구인가?

- 고객에게 필요한 데이터를 파악하고 있는 사람은 누구인가?

- 핵심 객체는 무엇인가?
  - 시스템의 핵심 객체 개념화 (데이터 모델링)

- 핵심 관계는 무엇인가?

- 시간은 어떤 역할을 하는가?
  - 데이터의 범위와 간격을 파악
    - 예: 로그는 최근 7일만 저장할 수도 있음

- 비용은 어떤 역할을 하는가?
  - 클라우드는 리소스에 제한이 없지만, 비용은 발생함

---

### 일반적인 고려사항

- BigQuery는 트랜잭션 DB가 아니다.
  - 테이블 수정에 의존하지 말 것

- 데이터 수명은 제한이 없다.
  - 디스크 공간, 계산 능력 제약 없음
  - ➝ 비용 및 규정 준수를 위해 데이터 수명을 고려할 것

- 시간은 UTC 기준으로 설정할 것
  - 모든 GCP 서비스가 UTC 기준

---

### 업무 승인 및 문서화

- 관계자 인터뷰 및 회의
- 용어의 정확한 의미 파악, 갈등 해결
- 문서 산출물
  - 데이터 출처
  - 데이터 용어집
  - 품의서
- 비즈니스 수용 및 결정 기록
- 문서 보관
  - 인트라넷 등 접근 가능한 위치에 보관
- 형상 관리 필요

---

### 설계 방식 선택

- **트랜잭션 저장소**
  - SQL Server, MySQL, Postgres 등 관계형 DB

- **스타/눈송이 스키마**
  - 중앙: 팩트 테이블, 주변: 차원 테이블
  - 스타 스키마: 탐색 용이, 공간 최적화
  - 눈송이 스키마: 정규화된 형태로 확장

- **NoSQL**
  - MongoDB, Google Cloud Datastore 등
  - 이벤트 기반 아키텍처로 구조화

- **BigQuery**
  - 중첩/반복 데이터 활용
  - 전통 OLAP 스키마 필요 없음

---

### BigQuery 모델 구성

- **프로젝트**
- **데이터 세트**
  - 테이블, 뷰, 저장 프로시저, 함수 포함
- **테이블**
  - 정규화/비정규화
  - 계층 구조 (예: JSON 객체 ➝ 행)
  - 테이블 파티션
    - 시간, 타임스탬프, 정수 키 기준 자동 버킷화
    - 파티션 만료 정책 설정 가능

---

### 요약

데이터 웨어하우스 프로젝트의 성공 조건:

1. 프로젝트 수행에 대한 기술적 이해
2. 비즈니스적 수용과 동의


# BigQuery 비용 관리

## BigQuery 모델

- BigQuery 및 기타 최신 데이터 스토리지 시스템은 **스토리지와 컴퓨팅 비용을 분리**한다.
- 저장 용량과 컴퓨팅 리소스는 각각 따로 과금된다.
- BigQuery에는 색인이 없으며 재구축이나 vacuuming 개념이 없다.

---

## BigQuery 비용 모델

### 스토리지 가격

- 데이터 보유량에 따라 청구
- 90일 이상 수정되지 않은 테이블은 **장기 스토리지**로 전환 → 절반 가격
- Cloud Storage → BigQuery 데이터 로드 시 무료
- 스트리밍 데이터 로드는 비용 발생

### 주문형 가격

- 기본 모델
- **처리된 바이트 기준으로 요금 청구**
- 월 1TB 쿼리 무료 제공
  - 최소 쿼리 크기 10MB
  - 작은 쿼리를 자주 실행하면 비용 증가 가능
  - LIMIT 사용해도 비용은 동일 (쿼리 전체 스캔 후 적용됨)

### 정액제

- **슬롯 단위로 구매**
- 예측 가능한 비용 모델
- 병렬 쿼리 증가 시 성능 저하 가능

### BigQuery 예약

- 정액제 + 주문형 결합 모델
- **예측된 지출과 유연한 용량 제공**

#### 구성 요소

- **약정**: 월간/연간 기준으로 슬롯 예약
- **예약**: 슬롯을 별도의 풀로 분할
- **할당**: 프로젝트별로 슬롯 할당 (QUERY, PIPELINE, ML_EXTERNAL 작업 분리 가능)

---

## 비용 최적화 전략

- 소규모 워크로드는 무료 등급 활용
- TB 수준은 상식적 비용, PB 수준은 철저한 관리 필요

### 연간 약정

- 고정 요금 + 예약 기반 할인 제공

### 테이블 분할 (파티셔닝)

- **쿼리 성능 향상 및 비용 절감**
  - 필요한 데이터 범위만 논리적 접근 가능

### 로딩 vs 스트리밍

- **로드: 무료**
- **스트리밍: 비용 발생**
  - 실시간 필요 없다면 로드를 사용

### 쿼리 작성 팁

- `SELECT *` **지양**
  - 열 기반 저장소에서는 과도한 비용 발생
- `LIMIT` 사용 시 처리 바이트에는 영향 없음
  - 관계형 DB와 다르게 작동

### 쿼리 비용 확인

- **BigQuery UI**에서 스캔 예상 바이트 확인 가능

---

## GCP 예산 도구

- **GCP 요금 계산기** 활용
- **사용자 지정 할당량 설정 가능**
  - Query Usage/일
  - Query Usage/일/사용자

### 예약 모델에서의 할당량

- 허용 슬롯 수 설정 가능

---

## 결론

- BigQuery 비용 측정은 간단하지 않다.
  - 주문형 모델은 유연하나 **비용 예측 어려움**
  - 고정 가격 모델은 **가용성과 효율성의 타협**이 필요
- 비용 발생 구조를 충분히 이해한 후, 적절한 결정을 내려야 한다.

# 예약 작업

출처: [Cyberciti - Cron Jobs](https://www.cyberciti.biz/faq/linux-show-what-cron-jobs-are-setup/)

## 예약 작업 개요

- 예시:
  - 기존 시스템의 데이터를 주기적으로 BigQuery에 로드
  - 매일 밤 유지 관리 및 규정 준수를 위한 작업 실행
- BigQuery에서는 **예약 쿼리** 기능 제공 (BigQuery 내에서만 작동)
- **Cloud Scheduler**는 서버리스 예약 작업 관리 도구

---

## BigQuery 예약 쿼리

- BigQuery Data Transfer Service를 통해 동작

### 예약 쿼리 설정

- **이름**: 소스-목적지-액션 형식 권장
- **일정**: 시간별/일별/주별/월별 또는 커스텀 문자열 지정
- **요청 시 실행**: 수동 실행용 예약 쿼리 생성 가능
- **시작일 및 실행 시간**: 시간대 고려 (기본 UTC)
- **결과 위치**: 결과 테이블 삽입 (추가/덮어쓰기)
- **알림**:
  - 이메일
  - Cloud Pub/Sub 토픽

---

## Cloud Scheduler

- **이름**: 작업을 설명하는 명확한 이름 사용
- **빈도**:
  - 크론 형식: [Cronhub](https://crontab.cronhub.io/)
  - BigQuery 형식: 영어로 일정 표현
- **대상**:
  - HTTP/HTTPS 요청
  - Pub/Sub 메시지 발행
  - App Engine HTTP 호출

---

## 스케줄링 모범 사례

- **활성화/비활성화**: 비활성 후 재활성화 시 즉시 실행 가능
- **멱등성**: 여러 번 실행 시 동일한 결과 보장
  - 예: 중복 로드 방지 (PK, unique, upsert 필요)
- **시간대**: 일광 절약 시간 등 주의
- **테스트**: 생성 후 바로 실행 및 로그 확인 권장
- **해상도**: 최소 1분 단위
- **중복 실행 방지**: 동일 작업은 동시에 두 번 실행 불가

---

## 다른 예약 방법

- **Cloud Tasks**:
  - 비동기 워크플로용 분산 실행 큐
  - 반복 작업 미지원
- **Cloud Composer**: Apache Airflow 기반
- **BigQuery Transfer Service**: 외부 데이터 전송용

---

## GCP의 서버리스 함수 (FaaS)

출처: [CustomizeWindows - FaaS](https://thecustomizewindows.com/2017/05/function-service-faas/#google_vignette)

### 개요

- FaaS = Functions as a Service
  - 예: AWS Lambda, GCP Cloud Functions
- 서버리스 기술은 관리 불필요한 확장성과 비용 효율 제공

### 장점

- **관리 불필요**
- **자동 확장**
- **저렴한 호출 비용**
- **높은 가용성**

### 단점

- **콜드 스타트 지연**
- **리소스 제한**
- **이식성 부족**
- **관리 복잡성**

---

## BigQuery와 Cloud Functions

- 적합 작업: **배치/예약/ETL/후처리**

### 함수 설정

- **함수 이름**: URL에 반영, 네임스페이스 주의
- **리전**: 실행 위치
- **트리거**: 호출 방식 (HTTP, Pub/Sub 등)
- **인증**: 인증 여부 설정
- **고급 설정**:
  - 메모리, 제한 시간, 인스턴스 수
  - 서비스 계정, 환경 변수, 네트워크 설정
- **코드 업로드**:
  - 인라인, ZIP, Cloud Storage, 소스 저장소

---

## Cloud Functions 트리거

- **HTTP 트리거**: 웹훅, 직접 호출
- **Cloud Pub/Sub 트리거**: 비동기 메시지
- **Cloud Storage 트리거**: 객체 업로드 감지
- **Cloud Firestore 트리거**: 문서 변경 감지
- **Firebase 트리거**: 모바일 분석 이벤트
- **Cloud Scheduler**: 예약 실행
- **직접 트리거**: 디버깅용

---

## 실전 예제: Ramen POS 자동화

### 기존 프로세스

1. POS 시스템 → 이메일 전송
2. 회계부 → 파일 저장
3. 공유 폴더 → 수동 로드

### 자동화 구성

- **파일 업로드**: CSV를 Cloud Storage에 업로드
- **파일 감지**: 객체 생성 트리거 사용
- **파일 처리**: Cloud Function으로 BigQuery에 로드

### 주의 사항

- **중복**: 파일 재업로드 방지 필요
- **유효성 검사**: 파일 포맷 확인
- **확장성**: 대용량 처리 대비
- **스키마 관리**: 변동 대응
- **관리**: 모든 구성 문서화 필요